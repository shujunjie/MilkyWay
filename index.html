<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é“¶æ²³ç³»ä¸å¤ªé˜³ç³»ç¼©æ”¾æ¼”ç¤º</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            pointer-events: none;
            background: rgba(10, 20, 40, 0.7);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(0, 210, 255, 0.3);
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.2);
            max-width: 300px;
        }
        h1 {
            margin: 0 0 15px 0;
            font-size: 22px;
            letter-spacing: 2px;
            text-transform: uppercase;
            background: linear-gradient(90deg, #00d2ff, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
        }
        p {
            margin: 8px 0;
            font-size: 13px;
            line-height: 1.5;
            color: #b0c4de;
        }
        .highlight {
            color: #00d2ff;
            font-weight: bold;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 16px;
            letter-spacing: 3px;
            text-transform: uppercase;
            transition: opacity 0.5s;
            text-align: center;
        }
        #error-msg {
            display: none;
            color: #ff4444;
            font-weight: bold;
            margin-top: 20px;
            font-size: 12px;
        }
    </style>
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥ OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="loading">
        System Initializing...
        <div id="error-msg">Error: Three.js connection failed.</div>
    </div>

    <div id="ui-layer">
        <h1>GALAXY EXPLORER</h1>
        <p>è§†å›¾çŠ¶æ€: <span id="view-status" class="highlight">é“¶æ²³ç³»å…¨æ™¯</span></p>
        <div style="height: 1px; background: rgba(255,255,255,0.1); margin: 10px 0;"></div>
        <p>ğŸ–±ï¸ <b>æ»šè½®</b>ï¼šç¼©æ”¾ (Zoom)</p>
        <p>ğŸ–±ï¸ <b>æ‹–æ‹½</b>ï¼šæ—‹è½¬ (Rotate)</p>
        <p>ğŸ‘‰ <b>å‘ä¸­å¿ƒæ”¾å¤§</b> è¿›å…¥å¤ªé˜³ç³»</p>
    </div>

    <div id="canvas-container"></div>

    <script>
        window.onload = function() {
            if (typeof THREE === 'undefined') {
                document.getElementById('error-msg').style.display = 'block';
                return;
            }
            init();
        };

        function init() {
            // --- 1. åœºæ™¯è®¾ç½® ---
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.0005); // æ›´æ·±é‚ƒçš„èƒŒæ™¯é›¾

            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(0, 400, 600);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // å¼€å¯é˜´å½±è´´å›¾ï¼Œè™½ç„¶è¿™é‡Œä¸»è¦é å‘å…‰ï¼Œä½†æœ‰é˜´å½±æ›´çœŸå®
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.6; // ç¨å¾®é™ä½æ›å…‰ï¼Œè®©å‘å…‰ç‰©ä½“æ›´æ˜æ˜¾
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 1500;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3; // ç¨å¾®æ…¢ä¸€ç‚¹ï¼Œæ›´ä¼˜é›…

            // --- 2. çº¹ç†ç”Ÿæˆå™¨ (ç¨‹åºåŒ–çº¹ç†ï¼Œæ— éœ€å¤–éƒ¨å›¾ç‰‡) ---
            function generatePlanetTexture(type, mainColor, secondaryColor) {
                const size = 512;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                // å¡«å……èƒŒæ™¯
                ctx.fillStyle = mainColor;
                ctx.fillRect(0, 0, size, size);

                if (type === 'gas') {
                    // æ°”ä½“è¡Œæ˜Ÿï¼šæ¡çº¹æ•ˆæœ
                    for (let i = 0; i < 20; i++) {
                        ctx.fillStyle = (i % 2 === 0) ? secondaryColor : mainColor;
                        ctx.globalAlpha = 0.2 + Math.random() * 0.3;
                        const y = Math.random() * size;
                        const h = Math.random() * (size / 10);
                        ctx.fillRect(0, y, size, h);
                    }
                    // åŠ ä¸€ç‚¹æ¨¡ç³Šå™ªéŸ³
                    ctx.globalAlpha = 0.05;
                    for(let i=0; i<5000; i++) {
                         ctx.fillStyle = '#fff';
                         ctx.fillRect(Math.random()*size, Math.random()*size, 2, 2);
                    }
                } else if (type === 'rocky') {
                    // å²©çŸ³è¡Œæ˜Ÿï¼šå™ªç‚¹æ–‘é©³æ•ˆæœ
                    for (let i = 0; i < 300; i++) {
                        ctx.beginPath();
                        ctx.arc(Math.random() * size, Math.random() * size, Math.random() * 20, 0, Math.PI * 2);
                        ctx.fillStyle = secondaryColor;
                        ctx.globalAlpha = 0.1 + Math.random() * 0.2;
                        ctx.fill();
                    }
                } else if (type === 'earth') {
                    // åœ°çƒï¼šæµ·æ´‹ä¸å¤§é™†
                    ctx.fillStyle = '#1a3b6e'; // æ·±æµ·
                    ctx.fillRect(0, 0, size, size);
                    // æ¨¡æ‹Ÿå¤§é™†
                    ctx.fillStyle = '#2e8b57'; // ç»¿è‰²
                    for(let i=0; i<20; i++) {
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath();
                        const x = Math.random() * size;
                        const y = Math.random() * size;
                        const r = 30 + Math.random() * 80;
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // äº‘å±‚
                    for(let i=0; i<15; i++) {
                        ctx.fillStyle = '#ffffff';
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.ellipse(Math.random()*size, Math.random()*size, Math.random()*100, Math.random()*30, 0, 0, Math.PI*2);
                        ctx.fill();
                    }
                } else if (type === 'sun') {
                    // å¤ªé˜³ï¼šç­‰ç¦»å­å™ªç‚¹
                    const grad = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    grad.addColorStop(0, '#ffffaa');
                    grad.addColorStop(1, '#ff8800');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0,0,size,size);
                }

                const texture = new THREE.CanvasTexture(canvas);
                return texture;
            }

            // --- 3. ä¼˜åŒ–åçš„æ ‡ç­¾ç³»ç»Ÿ ---
            function createLabel(text, subtext = "") {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                // æé«˜åˆ†è¾¨ç‡è®©æ–‡å­—æ¸…æ™°
                canvas.width = 256; 
                canvas.height = 128;
                
                // èƒŒæ™¯ (ç±»ä¼¼ HUD çš„èƒ¶å›Šå½¢çŠ¶)
                ctx.fillStyle = 'rgba(0, 20, 40, 0.6)';
                ctx.strokeStyle = 'rgba(0, 210, 255, 0.5)';
                ctx.lineWidth = 2;
                
                // åœ†è§’çŸ©å½¢è·¯å¾„
                const x = 10, y = 40, w = 236, h = 50, r = 10;
                ctx.beginPath();
                ctx.moveTo(x+r, y);
                ctx.lineTo(x+w-r, y);
                ctx.quadraticCurveTo(x+w, y, x+w, y+r);
                ctx.lineTo(x+w, y+h-r);
                ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
                ctx.lineTo(x+r, y+h);
                ctx.quadraticCurveTo(x, y+h, x, y+h-r);
                ctx.lineTo(x, y+r);
                ctx.quadraticCurveTo(x, y, x+r, y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // è£…é¥°çº¿
                ctx.beginPath();
                ctx.moveTo(canvas.width/2, y+h);
                ctx.lineTo(canvas.width/2, canvas.height);
                ctx.strokeStyle = 'rgba(0, 210, 255, 0.8)';
                ctx.stroke();

                // ä¸»æ–‡å­—
                ctx.font = 'Bold 28px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, canvas.width / 2, y + h/2 - 5);

                // å‰¯æ–‡å­— (è‹±æ–‡æˆ–æè¿°)
                if(subtext) {
                    ctx.font = '14px Arial';
                    ctx.fillStyle = '#88ccff';
                    ctx.fillText(subtext, canvas.width / 2, y + h/2 + 15);
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.minFilter = THREE.LinearFilter;
                
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(12, 6, 1); // è°ƒæ•´æ˜¾ç¤ºå¤§å°
                sprite.center.set(0.5, 0.8); // è°ƒæ•´é”šç‚¹ï¼Œè®©çº¿è¿ç€æ˜Ÿçƒ
                return sprite;
            }

            // --- 4. é“¶æ²³ç³»ç²’å­ (ä¿æŒåŸæœ‰ï¼Œç¨å¾®è°ƒæ•´é¢œè‰²) ---
            const galaxyGroup = new THREE.Group();
            scene.add(galaxyGroup);

            // ... (å¤ç”¨ä¹‹å‰çš„é“¶æ²³ç³»ä»£ç ï¼Œè°ƒæ•´ä¸€ç‚¹å‚æ•°)
            const galaxyParameters = {
                count: 30000, // å¢åŠ ç²’å­æ•°
                size: 0.1,    // ç¨å¾®å¤§ä¸€ç‚¹
                radius: 400,
                branches: 3,
                spin: 1,
                randomness: 0.2,
                randomnessPower: 3,
                insideColor: '#ffaa88', // æ›´æš–çš„æ ¸å¿ƒ
                outsideColor: '#0055ff' // æ›´å†·çš„è¾¹ç¼˜
            };
            
            // ... (ç”Ÿæˆé“¶æ²³ç³»çš„é€»è¾‘)
            const galaxyGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(galaxyParameters.count * 3);
            const colors = new Float32Array(galaxyParameters.count * 3);
            const colorInside = new THREE.Color(galaxyParameters.insideColor);
            const colorOutside = new THREE.Color(galaxyParameters.outsideColor);

            for(let i=0; i<galaxyParameters.count; i++){
                const i3 = i*3;
                const radius = Math.random() * galaxyParameters.radius;
                const spinAngle = radius * galaxyParameters.spin;
                const branchAngle = (i % galaxyParameters.branches)/galaxyParameters.branches * Math.PI*2;
                
                const randomX = Math.pow(Math.random(), galaxyParameters.randomnessPower) * (Math.random()<0.5?1:-1) * galaxyParameters.randomness * radius;
                const randomY = Math.pow(Math.random(), galaxyParameters.randomnessPower) * (Math.random()<0.5?1:-1) * galaxyParameters.randomness * radius;
                const randomZ = Math.pow(Math.random(), galaxyParameters.randomnessPower) * (Math.random()<0.5?1:-1) * galaxyParameters.randomness * radius;

                positions[i3] = Math.cos(branchAngle + spinAngle) * radius + randomX;
                positions[i3+1] = randomY * 2;
                positions[i3+2] = Math.sin(branchAngle + spinAngle) * radius + randomZ;

                const mixedColor = colorInside.clone();
                mixedColor.lerp(colorOutside, radius/galaxyParameters.radius);
                colors[i3] = mixedColor.r; colors[i3+1] = mixedColor.g; colors[i3+2] = mixedColor.b;
            }
            galaxyGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            galaxyGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const galaxyMat = new THREE.PointsMaterial({ size: galaxyParameters.size, sizeAttenuation: true, depthWrite: false, blending: THREE.AdditiveBlending, vertexColors: true });
            const galaxyPoints = new THREE.Points(galaxyGeo, galaxyMat);
            galaxyGroup.add(galaxyPoints);
            // é“¶æ²³æ ¸å¿ƒå…‰æ™•
            const coreSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/glow.png'),
                color: 0xffaa55, blending: THREE.AdditiveBlending
            }));
            coreSprite.scale.set(40,40,1);
            galaxyGroup.add(coreSprite);


            // --- 5. å¤ªé˜³ç³» (è§†è§‰å‡çº§ç‰ˆ) ---
            const solarSystemGroup = new THREE.Group();
            scene.add(solarSystemGroup);
            solarSystemGroup.visible = false;

            // å¤ªé˜³ä¸»ä½“
            const sunGeo = new THREE.SphereGeometry(5, 64, 64);
            const sunMat = new THREE.MeshStandardMaterial({
                map: generatePlanetTexture('sun', '#ffaa00', '#ff4400'),
                emissive: 0xffaa00,
                emissiveIntensity: 0.8,
                roughness: 0.4
            });
            const sun = new THREE.Mesh(sunGeo, sunMat);
            // å·¨å¤§çš„å¤ªé˜³å…‰è¾‰
            const sunGlow1 = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/glow.png'), color: 0xffcc00, blending: THREE.AdditiveBlending, opacity: 0.6 }));
            sunGlow1.scale.set(35, 35, 1);
            sun.add(sunGlow1);
            const sunGlow2 = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/glow.png'), color: 0xff4400, blending: THREE.AdditiveBlending, opacity: 0.4 }));
            sunGlow2.scale.set(50, 50, 1);
            sun.add(sunGlow2);
            
            solarSystemGroup.add(sun);
            sun.add(createLabel("å¤ªé˜³", "Sun"));

            // çœŸå®çš„å¤ªé˜³å…‰ç…§ (ç‚¹å…‰æº)
            const solarLight = new THREE.PointLight(0xffffff, 1.5, 400);
            solarLight.position.set(0, 0, 0);
            solarLight.castShadow = true;
            solarSystemGroup.add(solarLight);
            // ç¯å¢ƒå…‰ (è®©èƒŒå…‰é¢ä¸å®Œå…¨æ­»é»‘)
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
            solarSystemGroup.add(ambientLight);

            // è¡Œæ˜Ÿé…ç½®
            const planetsData = [
                { name: "æ°´æ˜Ÿ", en: "Mercury", type: "rocky", color1: "#8c7e6d", color2: "#5e5246", dist: 14, size: 0.8, speed: 1.5 },
                { name: "é‡‘æ˜Ÿ", en: "Venus", type: "gas", color1: "#e3bb76", color2: "#c49a50", dist: 22, size: 1.2, speed: 1.1 },
                { name: "åœ°çƒ", en: "Earth", type: "earth", color1: "#2233ff", color2: "#228833", dist: 32, size: 1.3, speed: 1.0 },
                { name: "ç«æ˜Ÿ", en: "Mars", type: "rocky", color1: "#c1440e", color2: "#8a2b06", dist: 42, size: 1.0, speed: 0.8 },
                { name: "æœ¨æ˜Ÿ", en: "Jupiter", type: "gas", color1: "#d9a066", color2: "#a87b4f", dist: 65, size: 4.0, speed: 0.4 },
                { name: "åœŸæ˜Ÿ", en: "Saturn", type: "gas", color1: "#ead6b8", color2: "#cba87c", dist: 90, size: 3.5, speed: 0.3, ring: true },
                { name: "å¤©ç‹æ˜Ÿ", en: "Uranus", type: "gas", color1: "#a6f2ff", color2: "#78d1e0", dist: 115, size: 2.2, speed: 0.2 },
                { name: "æµ·ç‹æ˜Ÿ", en: "Neptune", type: "gas", color1: "#4b70dd", color2: "#2d4aa0", dist: 140, size: 2.1, speed: 0.1 }
            ];

            const planetMeshes = [];

            planetsData.forEach(data => {
                const orbitGroup = new THREE.Group();
                orbitGroup.rotation.y = Math.random() * Math.PI * 2;

                // ä¼˜åŒ–è½¨é“çº¿ï¼šæ›´ç»†ï¼Œæ›´æ·¡
                const orbitGeo = new THREE.RingGeometry(data.dist - 0.05, data.dist + 0.05, 128);
                const orbitMat = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.1, transparent: true, side: THREE.DoubleSide });
                const orbitMesh = new THREE.Mesh(orbitGeo, orbitMat);
                orbitMesh.rotation.x = Math.PI / 2;
                solarSystemGroup.add(orbitMesh);

                // è¡Œæ˜Ÿæè´¨
                const tex = generatePlanetTexture(data.type, data.color1, data.color2);
                const mat = new THREE.MeshStandardMaterial({ 
                    map: tex, 
                    roughness: 0.8,
                    metalness: 0.1
                });
                const geo = new THREE.SphereGeometry(data.size, 32, 32);
                const planet = new THREE.Mesh(geo, mat);
                planet.position.set(data.dist, 0, 0);
                planet.castShadow = true;
                planet.receiveShadow = true;

                // åœŸæ˜Ÿç¯ä¼˜åŒ–
                if (data.ring) {
                    const ringGeo = new THREE.RingGeometry(data.size * 1.4, data.size * 2.5, 64);
                    // ç”Ÿæˆç¯çº¹ç†
                    const ringCanvas = document.createElement('canvas');
                    ringCanvas.width = 128; ringCanvas.height = 2;
                    const rctx = ringCanvas.getContext('2d');
                    rctx.fillStyle = '#cba87c'; rctx.fillRect(0,0,128,2);
                    rctx.fillStyle = '#000000'; rctx.globalAlpha=0.3; rctx.fillRect(30,0,10,2); rctx.fillRect(70,0,5,2);
                    const ringTex = new THREE.CanvasTexture(ringCanvas);
                    
                    const ringMat = new THREE.MeshStandardMaterial({ 
                        map: ringTex, side: THREE.DoubleSide, transparent: true, opacity: 0.8, roughness: 1 
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.rotation.x = Math.PI / 1.5;
                    planet.add(ring);
                }

                // æ·»åŠ æ ‡ç­¾
                const label = createLabel(data.name, data.en);
                label.position.set(0, data.size + 4, 0); // è°ƒæ•´é«˜åº¦
                planet.add(label);

                orbitGroup.add(planet);
                solarSystemGroup.add(orbitGroup);
                
                // è‡ªè½¬å’Œå…¬è½¬æ•°æ®
                planetMeshes.push({ 
                    orbit: orbitGroup, 
                    body: planet,
                    speed: data.speed, 
                    rotSpeed: 0.5 + Math.random() // è¡Œæ˜Ÿè‡ªè½¬é€Ÿåº¦
                });
            });


            // --- 6. é€»è¾‘ä¸åŠ¨ç”» ---
            const TRANSITION_START = 100;
            const TRANSITION_END = 30;
            const uiStatus = document.getElementById('view-status');

            function updateVisibility() {
                const dist = camera.position.distanceTo(controls.target);
                let galOp = 1;
                let solScale = 0;

                if (dist > TRANSITION_START) {
                    galOp = 1; solScale = 0;
                    uiStatus.innerHTML = "é“¶æ²³ç³»è¾¹ç¼˜ <span style='font-size:12px;color:#666'>Outer Rim</span>";
                    controls.autoRotateSpeed = 0.5;
                } else if (dist < TRANSITION_END) {
                    galOp = 0; solScale = 1;
                    uiStatus.innerHTML = "å¤ªé˜³ç³»å†…éƒ¨ <span style='font-size:12px;color:#666'>Solar System</span>";
                    controls.autoRotateSpeed = 0.1; // åœ¨å¤ªé˜³ç³»å†…è½¬æ…¢ç‚¹
                } else {
                    const t = (dist - TRANSITION_END) / (TRANSITION_START - TRANSITION_END);
                    galOp = t; solScale = 1 - t;
                    uiStatus.innerHTML = "è¶…å…‰é€Ÿç©¿è¶Š... <span style='font-size:12px;color:#666'>Warp Speed</span>";
                }

                if(galaxyPoints) {
                    galaxyPoints.material.opacity = galOp;
                    galaxyPoints.visible = galOp > 0.01;
                }

                solarSystemGroup.visible = solScale > 0.01;
                const s = Math.max(0.001, solScale);
                solarSystemGroup.scale.set(s,s,s);
            }

            const clock = new THREE.Clock();

            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();

                if (galaxyPoints.visible) {
                    galaxyGroup.rotation.y += delta * 0.03;
                }

                if (solarSystemGroup.visible) {
                    planetMeshes.forEach(obj => {
                        // å…¬è½¬
                        obj.orbit.rotation.y += delta * obj.speed * 0.2;
                        // è‡ªè½¬
                        obj.body.rotation.y += delta * obj.rotSpeed;
                    });
                    // å¤ªé˜³å¤§æ°”æµåŠ¨æ•ˆæœ
                    sunMat.map.offset.x += delta * 0.05;
                }

                controls.update();
                updateVisibility();
                renderer.render(scene, camera);
            }

            // UI ç§»é™¤åŠ è½½å±‚
            const loadingEl = document.getElementById('loading');
            if(loadingEl) loadingEl.style.opacity = 0;

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }
    </script>
</body>
</html>
